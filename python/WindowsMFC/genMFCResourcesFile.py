
# WHAT IS THIS
# This script generates two files {"ResourcesTemp.rc", "ResourcesTemp.h"} 
# The first describes the resources in the local filesystem under the 
# current directory where this script was run. The file contains a table 
# of ID_* # {BITMAP|ICON} and relative path to each resource of valid type.
# The second file (.h) contains a list of #define's for each of the ID_*'s 

# HOW TO USE
# place in any directory that contains bitmaps or icons.
# run/double click using at least python 2.7 probably.. 

# # # Settings # # #

# Set the following to the name of an existing header file with #defines.. 
# this file will be read and compared against the new set of id's for 
# uniqueness.. Every new ID_* not found in the existing header will be 
# added to the new ResourcesTemp.h (or as specified in a latter setting)
ExistingRCFile="" #'Resource.h'

# change the following to specify the name of the files to which to write 
# the RC table and #define list
NewResourcesFilename="ResourcesTemp"

# this is the first value an ID can be. Id's are generated by incrementing 
# from this number by 1
IdStartVal=450


from os import listdir
from os import walk
from os.path import isfile, join
from time import sleep
import glob, os
import re


# From current directory: looks for all files in every subdirectory
# and keeps track of the relative paths to such files.. Returns an 
# array of paths to the files
def FindAllFilePaths(rootDir, transform):
	# get set of relative file paths from the rootDir
	fileSet = set()
	for dir_, _, files in os.walk(rootDir):
		for fileName in files:
			relDir = os.path.relpath(dir_, rootDir)
			relFile = os.path.join(relDir, fileName)
			relFile = transform(relFile)
			fileSet.add(relFile)
	return fileSet

# replaces all '/' and '\' with '\\' re.sub(r'/',r'\\\\',path)
def ToDoubleBackslash(str):
	slashesLinuxToWindows = lambda path: re.sub(r'/+',r'\\',path)
	slashesWindowsDoubleBackSlash = lambda path: re.sub(r'\\',r'\\\\',path)
	return slashesWindowsDoubleBackSlash(slashesLinuxToWindows(str))

# describes a resource element tuple with columns {id, type, pathtores} 
class ResourceElement(object):
	"""docstring for ResourceElement"""
	def __init__(self, id, relativePath):
		super(ResourceElement, self).__init__()
		self.id = id 									# res locally unique id
		self.typeName = MakeResourceType(relativePath)	# res type name (printed 2nd)
		self.relativePath = relativePath 				# full path name (printed 3rd)
		# the name of the file (for determining res id name)
		self.resName = relativePath.split("\\")[-1]
		self.idName = "IDB_" + self.resName.split(".")[0].upper() # res id name (printed 1st)
	def pretty(self):
		return str(self.idName) + "		" + str(self.typeName) + "		\"" + str(self.relativePath) + "\""
	def getLineHeaderDefine(self):
		return "#define " + str(self.idName) + " " + str(self.id)
	def isValid(self):
		return len(self.idName) >= 0 and len(self.typeName) > 0 and len(self.relativePath) > 0

# helper for figuring out what type of resource is referenced,
# based on the resourcePath to the resource.. returns the type 
# string
def MakeResourceType(resourcePath):
	resType = ""
	if re.search(".bmp", resourcePath):
		resType = "BITMAP"
	elif re.search(".ico", resourcePath):
		resType = "ICON"
	return resType

def MakeResourceIdName(idNumber, resName):
	pass

def SortTableByResId(table):
	return table

def SortTableByResType(table):
	return table

def SortTableByResPath(table):
	return table

# given a search directory in which to find resources such as bitmaps 
# and icons. Generates a table of 3 columns. (1) Windows resource id: 
# ID_<filename> (2) Type of resource (ie: BITMAP..) (3) the relative 
# path to the file resource # with escaped backslashes. Returns array 
# of table elements{(1)(2)(3)}
def GenerateResourceTable(searchDir, idStartVal=0):
	listOfFilePaths = FindAllFilePaths(searchDir, lambda b: b)
	table = []
	for idx, val in enumerate(listOfFilePaths):
		val = ToDoubleBackslash(val)
		table.append(ResourceElement(idx + idStartVal, val))
	return table

# helper that appends suffix to s if s does not contain such suffix. 
# then returns s
def AppendIfNotEndsIn(s, suffix):
	if s.split(".")[-1] != suffix:
		s += suffix
	return s


# returns a pair of filenames whose basenames are the value 
# stored in filename.. if filename is empty then the base
# filename defaults to "resource".. then verifies that .h 
# and .rc suffix both filenames. returns both filenames in
# order: The rc file, The Header file name
def CreateFilenamePair(filename):
	rcFileName = filename;
	headerFileName = filename;
	if len(filename) == 0:
		rcFileName = "resource"
		headerFileName = "resource"
	rcFileName = AppendIfNotEndsIn(rcFileName, ".rc")
	headerFileName = AppendIfNotEndsIn(headerFileName, ".h")
	return rcFileName, headerFileName

# returns a 3 tuple of {preprocessor-token, key-token, value}
def CppParseDefine(line):
	tokens = line.split()
	if len(tokens) > 2:
		return (tokens[0], tokens[1], tokens[2])
	return tokens[0], tokens[1], -1

# takes a file to a header file and reads the #defines.. 
# returns a dictionary of key and value from #defines..
def ReadHeaderDefines(file):
	headerTable = {}
	if not file:
		return headerTable
	for line in file:
		line = line.split("//")[0] 
		if len(line) == 0: 
			continue # ignore full line comments
		if re.search("#define", line):
			token, key, val = CppParseDefine(line)
			headerTable[key] = val
		else:
			continue
	# TODO: the other good stuff
	return headerTable

# takes a filename or path to the header file to read and parse
def CreateHeaderTableFromFile(filename):
	existingTable = {}
	if len(filename) != 0:
		if os.path.isfile(filename):
			file = open(filename, 'r')
			existingTable = ReadHeaderDefines(file)
		else:
			print("Couldn't find Header File '" + filename + "'..")
	return existingTable


###  MAIN  ###

# creates two files .rc and .h. The RC contains the resource
# table where each row is a tuple {ID_, TYPE, PATH_TO_RESOURCE}
# the .H file is a header of #defines that define each valid ID_
# the 
def CreateResourcesFiles(filename="", idStartVal=0, existingHeaderFile=""):
	rcFileName, headerFileName = CreateFilenamePair(filename)

	print("Finding all files in the child directories..")
	table = GenerateResourceTable(".", idStartVal)
	table = SortTableByResType(table) # perform any sort of sorting here

	existingTable = CreateHeaderTableFromFile(existingHeaderFile)

	print("Writing MFC Resource File with Resource Table: {filename: " + rcFileName + "}")
	file = open(rcFileName, "w")
	for res in table:
		if res.isValid() and res.idName not in existingTable:
			file.write(res.pretty() + "\n");

	print("Writing MFC Header File with ID Defines: {filename: " + headerFileName + "}")
	file = open(headerFileName, "w")
	for res in table:
		if res.isValid() and res.idName not in existingTable:
			file.write(res.getLineHeaderDefine() + "\n");

	print("Done.")
	sleep(2)

CreateResourcesFiles(filename=NewResourcesFilename, idStartVal=IdStartVal, 
	existingHeaderFile=ExistingRCFile)

###  TESTS  ###

def Test_GenerateResourceTable():
	table = GenerateResourceTable(searchDir=".")
	for resource in table:
		print(resource.pretty())

# Test_GenerateResourceTable();
